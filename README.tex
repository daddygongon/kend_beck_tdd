% Created 2023-09-11 Mon 11:21
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\setcounter{secnumdepth}{2}
\author{Shigeto R. Nishitani}
\date{\today}
\title{Kent Beck's TDD example by Ruby}
\hypersetup{
 pdfauthor={Shigeto R. Nishitani},
 pdftitle={Kent Beck's TDD example by Ruby},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.1 (Org mode 9.5.2)}, 
 pdflang={Jp}}
\begin{document}

\maketitle
\tableofcontents


\section{Introduction}
\label{sec:orgcb5f71e}
Ruby implementations for Kent Beck's 'Test Driven Development by Example'

\section{c15 :: Mixed Currencies}
\label{sec:org9f4cd32}
大体終わったけど，それほど綺麗ではないね．
でも，だいぶ，JavaとRubyの差異がわかった．
さて，テキストにできるかな？？

\begin{itemize}
\item[{$\square$}] \$5 + 10CHF = \$10 (if rate is 2:1)
\item[{$\square$}] Return money from \$5 + \$5
\end{itemize}
\begin{verbatim}
test "mixed addition" do
  five_bucks = Money.new(5).dollar
  ten_francs = Money.new(10).franc
  bank = Bank.new
  bank.add_rate('CHF', 'USD', 2)

  result = bank.reduce(five_bucks.plus(ten_francs), 'USD')
  assert_true(Money.new(10).dollar.equals(result))
end
\end{verbatim}

\begin{verbatim}
class Sum
  def reduce(bank, to)
    amount = @augend.reduce(bank, to).amount +
	     @addend.reduce(bank, to).amount
    return Money.new(amount,to)
  end
end
\end{verbatim}

\section{c14 :: Change}
\label{sec:org37746b1}
\begin{itemize}
\item[{$\square$}] \$5 + 10CHF = \$10 (if rate is 2:1)
\item[{$\square$}] \$5 + \$5 = \$10
\item[{$\square$}] Return money from \$5 + \$5
\item[{$\square$}] Bank.reduce(Money)
\item[{$\square$}] Reduce Money with conversion
\item[{$\square$}] Reduce(Bank, String)
\end{itemize}

変換を実装するのですが，ややこしそうなので，ここで一旦中断．

Hashを使ってrateを取り出すことをしている．
Hash KeyをPairから作って，そのkeyから値を入れたり(puts),
出したり(gets)する機能(Map, HashMap)を使っているみたい．

実際にHash Key使っているのは， 
Pair.new('CHF', 'USD')でそれ以外はrate=1.0を
返せばいいので，そのままにしておく．
hash\_codeの実装を行えば，そこもうまくいくはず．

\begin{verbatim}
test "identity rate" do
  assert_equal(1.0, Bank.new.rate('USD', 'USD'))
end
test "hash test" do
  rate_table = {'USD'=>{'CHF'=>0.5, 'USD'=>1.0},
		'CHF'=>{'CHF'=>1.0, 'USD'=>2.0}}
  from = 'CHF'
  to = 'USD'
  assert_equal(2.0, rate_table[from][to])
end
\end{verbatim}

\begin{verbatim}
class Pair
  def initialize(from, to)
    @from = from
    @to = to
  end
  def equals(object)
    pair = Pair.new(object)
    return from.equals(pair.from) && to.equals(pair.to)
  end
  def hash_code()
    return 0
  end
end
class Bank
  def initialize
    @rates = {}
  end
  def add_rate(from, to, rate)
    @rates.store(Pair.new(from,to).hash_code, rate)
  end
  def reduce(source, to)
    return source.reduce(self, to)
  end
  def rate(from, to)
    return 1.0 if from==to
    return @rates[Pair.new(from,to).hash_code]
  end
end
class Money
  def reduce(bank, to)
    rate = bank.rate(@currency, to)
    return Money.new(@amount/rate, to)
  end
end
\end{verbatim}

\section{c13 :: Make It}
\label{sec:orgd22f9f8}
\begin{itemize}
\item[{$\square$}] \$5 + 10CHF = \$10 (if rate is 2:1)
\item[{$\square$}] \$5 + \$5 = \$10
\item[{$\square$}] Return money from \$5 + \$5
\end{itemize}

reduceをうまく，bank, sum, moneyに配置することで
codeを綺麗にする．
simple additionは一度動かなくなるが，comment outして
新しいtestで駆動しながら，最後のあたりで復活させる．

\begin{verbatim}
  class Sum
    public attr_reader :augend, :addend
    def initialize(augend, addend)
      @augend = augend
      @addend = addend
    end
    def reduce(to)
      amount = @augend.amount + @addend.amount
      return Money.new(amount,to)
    end
  end
  class Bank
    def reduce(source, to)
=begin      
      if source.class == Money
	return source.reduce(to)
      end
      sum = source
      return sum.reduce(to)
=end
      return source.reduce(to)
    end
  end
  class Money
...
    def plus(addend)
      return Sum.new(self, addend)
    end
    def reduce(to)
      return self
    end
  end
\end{verbatim}

\section{c12 :: Addition, Finally}
\label{sec:orgba252d1}
\begin{itemize}
\item[{$\square$}] \$5 + 10CHF = \$10 (if rate is 2:1)
\end{itemize}
さて，これ．
\begin{itemize}
\item[{$\square$}] \$5 + \$5 = \$10
\end{itemize}
をまずは実装．

さらにImposterパターンと呼ばれる手法でれに対処する．
reduce とか expressionとかが入ってくるのですが，
このあたりが難しそうなので，gitしましょう．

\begin{verbatim}
test "simple addition" do
  five = Money.new(5).dollar
  sum = five.plus(five)
  bank = Bank.new
  reduce = bank.reduce(sum, 'USD')
  assert_true(Money.new(10).dollar.equals(reduce))
end
\end{verbatim}

\begin{verbatim}
  class Bank
    def reduce(object, currency)
      amount = object.amount
      return Money.new(amount, currency)
    end
  end
  class Money
    public attr_reader :amount
...
\end{verbatim}
Bank内にreduceだけを作ったが，
ここで，object.amountにアクセスする必要が出てきて，
protected -> publicに変更．
\section{c11 :: The root of all evil}
\label{sec:org44852f8}
subclassを本当に消すには．．．

\begin{itemize}
\item[{$\boxtimes$}] Dollar Franc Duplication
\begin{itemize}
\item[{$\boxtimes$}] Common equals
\item[{$\boxtimes$}] Common times
\end{itemize}
\end{itemize}
\begin{verbatim}
test "dollar multiplication" do
  five = Money.new(5).dollar

  #    assert_equal(Dollar.new(10), product)
  assert_true(Money.new(10).dollar.equals(five.times(2)))
  assert_true(Money.new(15).dollar.equals(five.times(3)))
end

test "equality" do
  assert_true(Money.new(5).dollar.equals(Money.new(5).dollar))
  assert_false(Money.new(5).dollar.equals(Money.new(6).dollar))
  assert_false(Money.new(5).franc.equals(Money.new(5).dollar))
end

test "currency" do
  assert_equal("USD", Money.new(1).dollar.currency)
  assert_equal("CHF", Money.new(1).franc.currency)
end
\end{verbatim}

\begin{verbatim}
  class Money
    protected attr_reader :amount
    public attr_reader :currency
    def initialize(amount, currency=nil)
      @amount = amount
      @currency = currency
    end
    def equals(object)
      money = Money.new(object.amount)
#      p [object, money, self]
      return @amount == money.amount &&
	#        self.class == object.class
	self.currency == object.currency
    end
    def dollar
      return Money.new(@amount, 'USD')
    end
    def franc
      return Money.new(@amount, 'CHF')
    end
    def times(multiplier)
      return Money.new(@amount * multiplier, @currency)
    end
  end
\end{verbatim}
\section{c10 :: Interesting times}
\label{sec:orgbf12f7e}
timesを統一して，subclassを消しちゃう．
\begin{itemize}
\item[{$\square$}] Common times
\end{itemize}

toStringは面倒なので，pメソッドで代用．
equalsで出力．
classが違うことを確認できる．

\begin{verbatim}
test "different class equality" do
  assert_true(Money.new(10, 'CHF').equals(Franc.new(10, 'CHF')))
end
\end{verbatim}

\begin{verbatim}
  class Money
...
    def times(multiplier)
      return Money.new(@amount * multiplier, @currency)
    end
  end
  class Dollar < Money
  end
  class Franc < Money
  end
\end{verbatim}

\section{c9 :: Times We're Livin' in}
\label{sec:org002644c}
通貨の概念を，文字列で代用してみる．
\begin{itemize}
\item[{$\square$}] Currency?
\item[{$\square$}] Delete test Franc Multiplications?
\end{itemize}

CHF stands for Confoederatio Helvetica franc, 
where Confoederatio Helvetica is the Latin name for 
the Swiss Confederation.

Money classへの統合を試みるわけだが，
class生成時のdefaultをうまく使わないと
テストを大幅に書き換える必要が出てくる．

すなわち
\begin{verbatim}
class Money
  protected attr_reader :amount
  public attr_reader :currency
  def initialize(amount, currency=nil)
    @amount = amount
    @currency = currency
  end
\end{verbatim}
としてcurrencyが定義されてなくてもMoneyは生成されて，
さらに，Money.new(5).dollarとかで初めてちゃんと'USD'を
定義したclassのインスタンスが生成されるようにする．
いいのかな．．．Money.new(5, 'USD')がいいよね．
全部そうした方が．．．

\begin{verbatim}
test "currency" do
  assert_equal("USD", Money.new(1).dollar.currency)
  assert_equal("CHF", Money.new(1).franc.currency)
end
\end{verbatim}

\begin{verbatim}
  class Money
    protected attr_reader :amount
    public attr_reader :currency
    def initialize(amount, currency=nil)
      @amount = amount
      @currency = currency
    end
    def equals(object)
      money = Money.new(object.amount)
      return @amount == money.amount &&
	self.class == object.class
    end
    def dollar
      return Dollar.new(@amount, 'USD')
    end
    def franc
      return Franc.new(@amount, 'CHF')
    end
  end
  class Dollar < Money
    def initialize(amount, currency)
      super(amount, currency)
#      @currency = 'CHF'
    end
    def times(multiplier)
      return Money.new(@amount * multiplier).dollar
    end
  end
  class Franc < Money
    def initialize(amount, currency)
      super(amount, currency)
#      @currency = 'CHF'
    end
    def times(multiplier)
      return Money.new(@amount * multiplier).franc
    end
  end
\end{verbatim}
subclass Dollar, Francのinitializeは消してもいいが今は，そのまま．

\section{c8 :: Makin' Objects}
\label{sec:org4a593d9}
FrancとDollarを消そうというのだが，
それは，times? で終わるんだろうか？
まずFactory methodを使う．
\begin{itemize}
\item[{$\boxminus$}] Dollar Franc Duplication
\begin{itemize}
\item[{$\boxtimes$}] Common equals
\item[{$\square$}] Common times
\end{itemize}
\end{itemize}

\begin{verbatim}
test "dollar multiplication" do
  five = Money.new(5).dollar

  #    assert_equal(Dollar.new(10), product)
  assert_true(Money.new(10).dollar.equals(five.times(2)))
  assert_true(Money.new(15).dollar.equals(five.times(3)))
end

test "franc multiplication" do
  five = Money.new(5).franc

  #    assert_equal(Dollar.new(10), product)
  assert_true(Money.new(10).franc.equals(five.times(2)))
  assert_true(Money.new(15).franc.equals(five.times(3)))
end

test "equality" do
  assert_true(Money.new(5).dollar.equals(Money.new(5).dollar))
  assert_false(Money.new(5).dollar.equals(Money.new(6).dollar))
  assert_true(Money.new(5).franc.equals(Money.new(5).franc))
  assert_false(Money.new(5).franc.equals(Money.new(6).franc))
  assert_false(Money.new(5).franc.equals(Money.new(5).dollar))
end
\end{verbatim}

\begin{verbatim}
def dollar
  return Dollar.new(@amount)
end
def franc
  return Franc.new(@amount)
end
\end{verbatim}

\section{c7 :: Apples and Oranges}
\label{sec:org28bbda2}
FrancとDollarを比べる．
\begin{itemize}
\item[{$\boxtimes$}] Compare Francs with Dollars
\item[{$\square$}] Currency?

\item[{$\square$}] 疑問
textに従うと，
\begin{verbatim}
self.class == money.class
\end{verbatim}

とするべきだが，明らかに失敗するので，
\begin{verbatim}
self.class == object.class
\end{verbatim}

としている．
\end{itemize}

\section{c6 :: Equality for all, Redux}
\label{sec:orgb984f11}
前章でやったDollarをコピペしてFrancに変えちゃうのでは，
重複が多すぎるので，共通の親クラスを作ってReduxする．
\begin{itemize}
\item[{$\square$}] \$5 + 10CHF = \$10 (if rate is 2:1)
\item[{$\boxtimes$}] \$5 * 2 = \$10
\item[{$\boxtimes$}] Make "amount" private(protected)
\item[{$\boxtimes$}] Dollar side-effects?
\item[{$\square$}] Money rounding?
\item[{$\boxtimes$}] equals()
\item[{$\square$}] hashCode()
\item[{$\square$}] equal null
\item[{$\square$}] Equal object
\item[{$\square$}] 5 CHF *2 = 10 CHF
\item[{$\boxminus$}] Dollar Franc Duplication
\begin{itemize}
\item[{$\boxtimes$}] Common equals
\item[{$\square$}] Common times
\end{itemize}

\item[{$\square$}] 疑問
p. 75あたりのobjectのキャストがうまくいかない．
\begin{verbatim}
money = Money.new(object)
\end{verbatim}

ではダメで，
\begin{verbatim}
money = Money.new(object.amount)
\end{verbatim}

として対応．これが後で不幸を招くかも．
ついでにinitializeもMoneyで作っておく必要がある．
\end{itemize}

\begin{verbatim}
test "equality" do
  assert_true(Dollar.new(5).equals(Dollar.new(5)))
  assert_false(Dollar.new(5).equals(Dollar.new(6)))
  assert_true(Franc.new(5).equals(Franc.new(5)))
  assert_false(Franc.new(5).equals(Franc.new(6)))
end
\end{verbatim}

\begin{verbatim}
class Money
  protected attr_reader :amount
  def initialize(amount)
    @amount = amount
  end
  def equals(object)
    money = Money.new(object.amount)
    return @amount == money.amount
  end
end
class Dollar < Money
  def times(multiplier)
    return Dollar.new(@amount * multiplier)
  end
end
class Franc < Money
  def times(multiplier)
    return Franc.new(@amount * multiplier)
  end
end
\end{verbatim}

\section{c5 :: Franc-ly Speaking}
\label{sec:orgb7ceb0c}
\begin{itemize}
\item[{$\square$}] \$5 + 10CHF = \$10 (if rate is 2:1)
\item[{$\boxtimes$}] \$5 * 2 = \$10
\item[{$\boxtimes$}] Make "amount" private(protected)
\item[{$\boxtimes$}] Dollar side-effects?
\item[{$\square$}] Money rounding?
\item[{$\boxtimes$}] equals()
\item[{$\square$}] hashCode()
\item[{$\square$}] equal null
\item[{$\square$}] Equal object
\item[{$\square$}] 5 CHF *2 = 10 CHF
\end{itemize}

\begin{verbatim}
test "franc multiplication" do
  five = Franc.new(5)

  #    assert_equal(Dollar.new(10), product)
  assert_true(Franc.new(10).equals(five.times(2)))
  assert_true(Franc.new(15).equals(five.times(3)))
end
\end{verbatim}

\begin{verbatim}
class Franc
  protected attr_reader :amount
  def initialize(amount)
    @amount = amount
  end
  def times(multiplier)
    return Franc.new(@amount * multiplier)
  end
  def equals(object)
    franc = object
    return @amount == franc.amount
  end
end
\end{verbatim}

\section{c4 :: Privacy}
\label{sec:org17877cb}
\begin{itemize}
\item[{$\square$}] \$5 + 10CHF = \$10 (if rate is 2:1)
\item[{$\boxtimes$}] \$5 * 2 = \$10
\item[{$\boxtimes$}] Make "amount" private(protected)
\item[{$\boxtimes$}] Dollar side-effects?
\item[{$\square$}] Money rounding?
\item[{$\boxtimes$}] equals()
\item[{$\square$}] hashCode()
\item[{$\square$}] equal null
\item[{$\square$}] Equal object

\item[{$\square$}] 疑問1
c4の最初のtest変更はobject同士の比較となる．
\begin{verbatim}
assert_equal(Dollar.new(10), product)
\end{verbatim}

javaのassertEqualsのpropertyと思われるが，
assertEqualsが最初の引数のequals関数を呼び出しているものと
思われる．
Rubyでこれを実装するのは難しそう．なので，
\begin{verbatim}
assert_true(Dollar.new(10).equals(product))
\end{verbatim}

と書き換える．Dollarの実装はそのまま．

\item[{$\square$}] 疑問2
「@amountをprivateにする」という説明があるが，
これを失敗する．
equals method内でdollar.amountを使っているから．
この辺り，JavaのprivateとRubyのprivateの違いかも．
ここをRubyではprotectedにしている．
Rubyのprotected, private, public宣言は3.0からなので
注意が必要かも．
\end{itemize}

\begin{verbatim}
class Dollar
  protected attr_reader :amount
\end{verbatim}

\begin{verbatim}
test "multiplication" do
  five = Dollar.new(5)

  #    assert_equal(Dollar.new(10), product)
  assert_true(Dollar.new(10).equals(five.times(2)))
  assert_true(Dollar.new(15).equals(five.times(3)))
end
\end{verbatim}
\section{c3 :: Equality for All}
\label{sec:orgc153e61}
\begin{itemize}
\item[{$\square$}] \$5 + 10CHF = \$10 (if rate is 2:1)
\item[{$\boxtimes$}] \$5 * 2 = \$10
\item[{$\square$}] Make "amount" private
\item[{$\boxtimes$}] Dollar side-effects?
\item[{$\square$}] Money rounding?
\item[{$\boxtimes$}] equals()
\item[{$\square$}] hashCode()
\end{itemize}

\begin{verbatim}
test "equality" do
  assert_true(Dollar.new(5).equals(Dollar.new(5)))
  assert_false(Dollar.new(5).equals(Dollar.new(6)))
end
\end{verbatim}

\begin{verbatim}
def equals(object)
  dollar = object
  return @amount == dollar.amount
end
\end{verbatim}

\section{c2 :: Degenerate Objects}
\label{sec:orgf58e0b7}
\begin{itemize}
\item[{$\square$}] \$5 + 10CHF = \$10 (if rate is 2:1)
\item[{$\boxtimes$}] \$5 * 2 = \$10
\item[{$\square$}] Make "amount" private
\item[{$\square$}] Dollar side-effects?
\item[{$\square$}] Money rounding?

\item[{$\square$}] 疑問
product = Dollar.new(five.times(2))となるはずだが，error
が出るんで，product = five.times(2)と修正．timesがDollarを
返してるんで．．．
\end{itemize}


\begin{verbatim}
# frozen_string_literal: true
require "test_helper"
class TddExample2Test < Test::Unit::TestCase
  include TddExample2
  test "multiplication" do
    five = Dollar.new(5)
    product = five.times(2)
    assert_equal(10, product.amount)
    product = five.times(3)
    assert_equal(15, product.amount)
  end
end
\end{verbatim}

\begin{verbatim}
# frozen_string_literal: true

require_relative "tdd_example2/version"

module TddExample2
  class Error < StandardError; end
  # Your code goes here...
  class Dollar
    attr_reader :amount
    def initialize(amount)
      @amount = amount
    end
    def times(multiplier)
      return Dollar.new(@amount * multiplier)
    end
  end
end
\end{verbatim}


\section{c1 :: Multi-Currency Money}
\label{sec:orgc276672}
\begin{itemize}
\item[{$\square$}] \$5 + 10CHF = \$10 (if rate is 2:1)
\item[{$\square$}] \$5 * 2 = \$10
\begin{itemize}
\item[{$\square$}] Make "amount" private
\item[{$\square$}] Dollar side-effects?
\item[{$\square$}] Money rounding?
\end{itemize}
\end{itemize}
\begin{verbatim}
# frozen_string_literal: true

require "test_helper"

class TddExample2Test < Test::Unit::TestCase
  include TddExample2
  test "VERSION" do
    assert do
      ::TddExample2.const_defined?(:VERSION)
    end
  end

  test "multiplication" do
    five = Dollar.new(5)
    five.times(2)
    assert_equal(10, five.amount)
  end
end
\end{verbatim}

\begin{verbatim}
# frozen_string_literal: true

require_relative "tdd_example2/version"

module TddExample2
  class Error < StandardError; end
  # Your code goes here...
  class Dollar
    attr_reader :amount
    def initialize(amount)
      @amount = amount
    end
    def times(multiplier)
      @amount *= multiplier
    end
  end
end
\end{verbatim}
\end{document}